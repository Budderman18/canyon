From bdaa8a253e84c8cb34de1d5be34e6c8a5cd42525 Mon Sep 17 00:00:00 2001
From: "@KoboDev" <KoboDev@mail.com>
Date: Thu, 18 Feb 2021 08:57:51 -0600
Subject: [PATCH] hope inventory api works


diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
index dbea05bc..55e039cb 100644
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -1,461 +1,203 @@
 package org.bukkit;
 
-import org.bukkit.generator.ChunkGenerator;
 import com.avaje.ebean.config.ServerConfig;
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.Recipe;
-
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 import java.util.logging.Logger;
-import org.bukkit.command.PluginCommand;
-
 import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.command.PluginCommand;
+import org.bukkit.entity.Player;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.inventory.Inventory;
+import org.bukkit.inventory.Recipe;
 import org.bukkit.map.MapView;
 import org.bukkit.plugin.PluginManager;
 import org.bukkit.plugin.ServicesManager;
 import org.bukkit.scheduler.BukkitScheduler;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.inventory.InventoryHolder;
 
-/**
- * Represents a server implementation
- */
 public interface Server {
-    /**
-     * Used for all administrative messages, such as an operator using a command.
-     *
-     * For use in {@link #broadcast(java.lang.String, java.lang.String)}
-     */
-    public static final String BROADCAST_CHANNEL_ADMINISTRATIVE = "bukkit.broadcast.admin";
-
-    /**
-     * Used for all announcement messages, such as informing users that a player has joined.
-     *
-     * For use in {@link #broadcast(java.lang.String, java.lang.String)}
-     */
-    public static final String BROADCAST_CHANNEL_USERS = "bukkit.broadcast.user";
-
-    /**
-     * Gets the name of this server implementation
-     *
-     * @return name of this server implementation
-     */
-    public String getName();
-
-    /**
-     * Gets the version string of this server implementation.
-     *
-     * @return version of this server implementation
-     */
-    public String getVersion();
-
-    /**
-     * Gets a list of all currently logged in players
-     *
-     * @return An array of Players that are currently online
-     */
-    public Player[] getOnlinePlayers();
-
-    /**
-     * Get the maximum amount of players which can login to this server
-     *
-     * @return The amount of players this server allows
-     */
-    public int getMaxPlayers();
-
-    /**
-     * Get the game port that the server runs on
-     *
-     * @return The port number of this server
-     */
-    public int getPort();
-
-    /**
-     * Get the view distance from this server.
-     *
-     * @return The view distance from this server.
-     */
-    public int getViewDistance();
-
-    /**
-     * Get the IP that this server is bound to or empty string if not specified
-     *
-     * @return The IP string that this server is bound to, otherwise empty string
-     */
-    public String getIp();
-
-    /**
-     * Get the name of this server
-     *
-     * @return The name of this server
-     */
-    public String getServerName();
-
-    /**
-     * Get an ID of this server. The ID is a simple generally alphanumeric
-     * ID that can be used for uniquely identifying this server.
-     *
-     * @return The ID of this server
-     */
-    public String getServerId();
-
-    /**
-     * Gets whether this server allows the Nether or not.
-     *
-     * @return Whether this server allows the Nether or not.
-     */
-    public boolean getAllowNether();
-
-    /**
-     * Gets whether this server has a whitelist or not.
-     *
-     * @return Whether this server has a whitelist or not.
-     */
-    public boolean hasWhitelist();
-
-    /**
-     * Sets the whitelist on or off
-     *
-     * @param value true if whitelist is on, otherwise false
-     */
-    public void setWhitelist(boolean value);
-
-    /**
-     * Gets a list of whitelisted players
-     *
-     * @return Set containing all whitelisted players
-     */
-    public Set<OfflinePlayer> getWhitelistedPlayers();
-
-    /**
-     * Reloads the whitelist from disk
-     */
-    public void reloadWhitelist();
-
-    /**
-     * Broadcast a message to all players.
-     *
-     * This is the same as calling {@link #broadcast(java.lang.String, java.lang.String)} to {@link #BROADCAST_CHANNEL_USERS}
-     *
-     * @param message the message
-     * @return the number of players
-     */
-    public int broadcastMessage(String message);
-
-    /**
-     * Gets the name of the update folder. The update folder is used to safely update
-     * plugins at the right moment on a plugin load.
-     *
-     * @return The name of the update folder
-     */
-    public String getUpdateFolder();
-
-    /**
-     * Gets a player object by the given username
-     *
-     * This method may not return objects for offline players
-     *
-     * @param name Name to look up
-     * @return Player if it was found, otherwise null
-     */
-    public Player getPlayer(String name);
-
-    /**
-     * Gets the player with the exact given name, case insensitive
-     *
-     * @param name Exact name of the player to retrieve
-     * @return Player object or null if not found
-     */
-    public Player getPlayerExact(String name);
-
-    /**
-     * Attempts to match any players with the given name, and returns a list
-     * of all possibly matches
-     *
-     * This list is not sorted in any particular order. If an exact match is found,
-     * the returned list will only contain a single result.
-     *
-     * @param name Name to match
-     * @return List of all possible players
-     */
-    public List<Player> matchPlayer(String name);
-
-    /**
-     * Gets the PluginManager for interfacing with plugins
-     *
-     * @return PluginManager for this Server instance
-     */
-    public PluginManager getPluginManager();
-
-    /**
-     * Gets the Scheduler for managing scheduled events
-     *
-     * @return Scheduler for this Server instance
-     */
-    public BukkitScheduler getScheduler();
-
-    /**
-     * Gets a services manager
-     *
-     * @return Services manager
-     */
-    public ServicesManager getServicesManager();
-
-    /**
-     * Gets a list of all worlds on this server
-     *
-     * @return A list of worlds
-     */
-    public List<World> getWorlds();
-
-    /**
-     * Creates or loads a world with the given name.
-     * If the world is already loaded, it will just return the equivalent of
-     * getWorld(name)
-     *
-     * @param name Name of the world to load
-     * @param environment Environment type of the world
-     * @return Newly created or loaded World
-     */
-    public World createWorld(String name, World.Environment environment);
-
-    /**
-     * Creates or loads a world with the given name.
-     * If the world is already loaded, it will just return the equivalent of
-     * getWorld(name)
-     *
-     * @param name Name of the world to load
-     * @param environment Environment type of the world
-     * @param seed Seed value to create the world with
-     * @return Newly created or loaded World
-     */
-    public World createWorld(String name, World.Environment environment, long seed);
-
-    /**
-     * Creates or loads a world with the given name.
-     * If the world is already loaded, it will just return the equivalent of
-     * getWorld(name)
-     *
-     * @param name Name of the world to load
-     * @param environment Environment type of the world
-     * @param generator ChunkGenerator to use in the construction of the new world
-     * @return Newly created or loaded World
-     */
-    public World createWorld(String name, World.Environment environment, ChunkGenerator generator);
-
-    /**
-     * Creates or loads a world with the given name.
-     * If the world is already loaded, it will just return the equivalent of
-     * getWorld(name)
-     *
-     * @param name Name of the world to load
-     * @param environment Environment type of the world
-     * @param seed Seed value to create the world with
-     * @param generator ChunkGenerator to use in the construction of the new world
-     * @return Newly created or loaded World
-     */
-    public World createWorld(String name, World.Environment environment, long seed, ChunkGenerator generator);
-
-     /**
-     * Unloads a world with the given name.
-     *
-     * @param name Name of the world to unload
-     * @param save Whether to save the chunks before unloading.
-     * @return Whether the action was Successful
-     */
-    public boolean unloadWorld(String name, boolean save);
-
-    /**
-     * Unloads the given world.
-     *
-     * @param world The world to unload
-     * @param save Whether to save the chunks before unloading.
-     * @return Whether the action was Successful
-     */
-    public boolean unloadWorld(World world, boolean save);
-
-    /**
-     * Gets the world with the given name
-     *
-     * @param name Name of the world to retrieve
-     * @return World with the given name, or null if none exists
-     */
-    public World getWorld(String name);
-
-    /**
-     * Gets the world from the given Unique ID
-     *
-     * @param uid Unique ID of the world to retrieve.
-     * @return World with the given Unique ID, or null if none exists.
-     */
-    public World getWorld(UUID uid);
-    
-    /**
-     * Gets the map from the given item ID.
-     * 
-     * @param id ID of the map to get.
-     * @return The MapView if it exists, or null otherwise.
-     */
-    public MapView getMap(short id);
-    
-    /**
-     * Create a new map with an automatically assigned ID.
-     * 
-     * @param world The world the map will belong to.
-     * @return The MapView just created.
-     */
-    public MapView createMap(World world);
-
-    /**
-     * Reloads the server, refreshing settings and plugin information
-     */
-    public void reload();
-
-    /**
-     * Returns the primary logger associated with this server instance
-     *
-     * @return Logger associated with this server
-     */
-    public Logger getLogger();
-
-    /**
-     * Gets a {@link PluginCommand} with the given name or alias
-     *
-     * @param name Name of the command to retrieve
-     * @return PluginCommand if found, otherwise null
-     */
-    public PluginCommand getPluginCommand(String name);
-
-    /**
-     * Writes loaded players to disk
-     */
-    public void savePlayers();
-
-    /**
-     * Dispatches a command on the server, and executes it if found.
-     *
-     * @param cmdLine command + arguments. Example: "test abc 123"
-     * @return targetFound returns false if no target is found.
-     * @throws CommandException Thrown when the executor for the given command fails with an unhandled exception
-     */
-    public boolean dispatchCommand(CommandSender sender, String commandLine);
-
-    /**
-     * Populates a given {@link ServerConfig} with values attributes to this server
-     *
-     * @param config ServerConfig to populate
-     */
-    public void configureDbConfig(ServerConfig config);
-
-    /**
-     * Adds a recipe to the crafting manager.
-     * @param recipe The recipe to add.
-     * @return True to indicate that the recipe was added.
-     */
-    public boolean addRecipe(Recipe recipe);
-
-    /**
-     * Gets a list of command aliases defined in the server properties.
-     *
-     * @return Map of aliases to command names
-     */
-    public Map<String, String[]> getCommandAliases();
-
-    /**
-     * Gets the radius, in blocks, around each worlds spawn point to protect
-     *
-     * @return Spawn radius, or 0 if none
-     */
-    public int getSpawnRadius();
-
-    /**
-     * Sets the radius, in blocks, around each worlds spawn point to protect
-     *
-     * @param value New spawn radius, or 0 if none
-     */
-    public void setSpawnRadius(int value);
-
-    /**
-     * Gets whether the Server is in online mode or not.
-     *
-     * @return Whether the server is in online mode.
-     */
-    public boolean getOnlineMode();
-
-    /**
-     * Gets whether this server allows flying or not.
-     *
-     * @return Whether this server allows flying or not.
-     */
-    public boolean getAllowFlight();
-
-    /**
-     * Shutdowns the server, stopping everything.
-     */
-    public void shutdown();
-
-    /**
-     * Broadcasts the specified message to every user with the given permission
-     *
-     * @param message Message to broadcast
-     * @param permission Permission the users must have to receive the broadcast
-     * @return Amount of users who received the message
-     */
-    public int broadcast(String message, String permission);
-
-    /**
-     * Gets the player by the given name, regardless if they are offline or online.
-     *
-     * This will return an object even if the player does not exist. To this method, all players will exist.
-     *
-     * @param name Name of the player to retrieve
-     * @return OfflinePlayer object
-     */
-    public OfflinePlayer getOfflinePlayer(String name);
-
-    /**
-     * Gets a set containing all current IPs that are banned
-     *
-     * @return Set containing banned IP addresses
-     */
-    public Set<String> getIPBans();
+  public static final String BROADCAST_CHANNEL_ADMINISTRATIVE = "bukkit.broadcast.admin";
+  
+  public static final String BROADCAST_CHANNEL_USERS = "bukkit.broadcast.user";
+  
+  String getName();
+  
+  String getVersion();
+  
+  Player[] getOnlinePlayers();
+  
+  int getMaxPlayers();
+  
+  int getPort();
+  
+  int getViewDistance();
+  
+  String getIp();
+  
+  String getServerName();
+  
+  String getServerId();
+  
+  boolean getAllowNether();
+  
+  boolean hasWhitelist();
+  
+  void setWhitelist(boolean paramBoolean);
+  
+  Set<OfflinePlayer> getWhitelistedPlayers();
+  
+  void reloadWhitelist();
+  
+  int broadcastMessage(String paramString);
+  
+  String getUpdateFolder();
+  
+  Player getPlayer(String paramString);
+  
+  Player getPlayerExact(String paramString);
+  
+  List<Player> matchPlayer(String paramString);
+  
+  PluginManager getPluginManager();
+  
+  BukkitScheduler getScheduler();
+  
+  ServicesManager getServicesManager();
+  
+  List<World> getWorlds();
+  
+  World createWorld(String paramString, World.Environment paramEnvironment);
+  
+  World createWorld(String paramString, World.Environment paramEnvironment, long paramLong);
+  
+  World createWorld(String paramString, World.Environment paramEnvironment, ChunkGenerator paramChunkGenerator);
+  
+  World createWorld(String paramString, World.Environment paramEnvironment, long paramLong, ChunkGenerator paramChunkGenerator);
+  
+  boolean unloadWorld(String paramString, boolean paramBoolean);
+  
+  boolean unloadWorld(World paramWorld, boolean paramBoolean);
+  
+  World getWorld(String paramString);
+  
+  World getWorld(UUID paramUUID);
+  
+  MapView getMap(short paramShort);
+  
+  MapView createMap(World paramWorld);
+
+  /**
+   * Creates an empty inventory of the specified type. If the type is {@link InventoryType#CHEST},
+   * the new inventory has a size of 27; otherwise the new inventory has the normal size for
+   * its type.
+   *
+   * @param owner The holder of the inventory; can be null if there's no holder.
+   * @param type The type of inventory to create.
+   * @return The new inventory.
+   */
+  Inventory createInventory(InventoryHolder owner, InventoryType type);
+
+  /**
+   * Creates an empty inventory of type {@link InventoryType#CHEST} with the specified size.
+   *
+   * @param owner The holder of the inventory; can be null if there's no holder.
+   * @param size The size of inventory to create; must be a multiple of 9.
+   * @return The new inventory.
+   * @throws IllegalArgumentException If the size is not a multiple of 9.
+   */
+  Inventory createInventory(InventoryHolder owner, int size);
+
+  /**
+   * Creates an empty inventory of type {@link InventoryType#CHEST} with the specified size and title.
+   *
+   * @param owner The holder of the inventory; can be null if there's no holder.
+   * @param size The size of inventory to create; must be a multiple of 9.
+   * @param title The title of the inventory, to be displayed when it is viewed.
+   * @return The new inventory.
+   * @throws IllegalArgumentException If the size is not a multiple of 9.
+   */
+  Inventory createInventory(InventoryHolder owner, int size, String title);
+  
+  void reload();
+  
+  Logger getLogger();
+  
+  PluginCommand getPluginCommand(String paramString);
+  
+  void savePlayers();
+  
+  boolean dispatchCommand(CommandSender paramCommandSender, String paramString);
+  
+  void configureDbConfig(ServerConfig paramServerConfig);
+  
+  boolean addRecipe(Recipe paramRecipe);
+  
+  Map<String, String[]> getCommandAliases();
+  
+  int getSpawnRadius();
+  
+  void setSpawnRadius(int paramInt);
+  
+  boolean getOnlineMode();
+  
+  boolean getAllowFlight();
+  
+  void shutdown();
+  
+  int broadcast(String paramString1, String paramString2);
+  
+  OfflinePlayer getOfflinePlayer(String paramString);
+  
+  Set<String> getIPBans();
+  
+  void banIP(String paramString);
+  
+  void unbanIP(String paramString);
+  
+  Set<OfflinePlayer> getBannedPlayers();
+  
+  double[] getTPS();
+  
+  ConsoleCommandSender getConsoleSender();
+}
 
-    /**
-     * Bans the specified address from the server
-     *
-     * @param address IP address to ban
-     */
-    public void banIP(String address);
 
-    /**
-     * Unbans the specified address from the server
-     *
-     * @param address IP address to unban
-     */
-    public void unbanIP(String address);
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/Server.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
 
-    /**
-     * Gets a set containing all banned players
-     *
-     * @return Set containing banned players
-     */
-    public Set<OfflinePlayer> getBannedPlayers();
+/*
+ * Creates an empty inventory of the specified type. If the type is {@link InventoryType#CHEST},
+ * the new inventory has a size of 27; otherwise the new inventory has the normal size for
+ * its type.
+ *
+ * @param owner The holder of the inventory; can be null if there's no holder.
+ * @param type The type of inventory to create.
+ * @return The new inventory.
+ */
 
-    // Canyon start
-    /**
-     * Gets the current server TPS
-     *
-     * @return current server TPS (1m, 5m, 15m in Canyon-Server)
-     */
-    public double[] getTPS();
-    // Canyon end
+/*
+ * Creates an empty inventory of type {@link InventoryType#CHEST} with the specified size and title.
+ *
+ * @param owner The holder of the inventory; can be null if there's no holder.
+ * @param size The size of inventory to create; must be a multiple of 9.
+ * @param title The title of the inventory, to be displayed when it is viewed.
+ * @return The new inventory.
+ * @throws IllegalArgumentException If the size is not a multiple of 9.
+ */
 
-    // Canyon start
-    /**
-     * Returns a command sender representing the console
-     * @return a console command sender
-     */
-    org.bukkit.command.ConsoleCommandSender getConsoleSender();
-    // Canyon end
-}
+/*
+ * Creates an empty inventory of type {@link InventoryType#CHEST} with the specified size and title.
+ *
+ * @param owner The holder of the inventory; can be null if there's no holder.
+ * @param size The size of inventory to create; must be a multiple of 9.
+ * @param title The title of the inventory, to be displayed when it is viewed.
+ * @return The new inventory.
+ * @throws IllegalArgumentException If the size is not a multiple of 9.
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/inventory/FurnaceBurnEvent.java b/src/main/java/org/bukkit/event/inventory/FurnaceBurnEvent.java
index d455864f..29ccf9e6 100644
--- a/src/main/java/org/bukkit/event/inventory/FurnaceBurnEvent.java
+++ b/src/main/java/org/bukkit/event/inventory/FurnaceBurnEvent.java
@@ -1,88 +1,94 @@
-package org.bukkit.event.inventory;
+/*    */ package org.bukkit.event.inventory;
+/*    */ 
+/*    */ import org.bukkit.block.Block;
+/*    */ import org.bukkit.event.Cancellable;
+/*    */ import org.bukkit.event.Event;
+/*    */ import org.bukkit.inventory.ItemStack;
+/*    */ 
+/*    */ public class FurnaceBurnEvent
+/*    */   extends Event
+/*    */   implements Cancellable {
+/*    */   private Block furnace;
+/*    */   private ItemStack fuel;
+/*    */   private int burnTime;
+/*    */   private boolean cancelled;
+/*    */   private boolean burning;
+/*    */   
+/*    */   public FurnaceBurnEvent(Block furnace, ItemStack fuel, int burnTime) {
+/* 18 */     super(Event.Type.FURNACE_BURN);
+/*    */     
+/* 20 */     this.furnace = furnace;
+/* 21 */     this.fuel = fuel;
+/* 22 */     this.burnTime = burnTime;
+/* 23 */     this.cancelled = false;
+/* 24 */     this.burning = true;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public Block getFurnace() {
+/* 33 */     return this.furnace;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public ItemStack getFuel() {
+/* 42 */     return this.fuel;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public int getBurnTime() {
+/* 51 */     return this.burnTime;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public void setBurnTime(int burnTime) {
+/* 60 */     this.burnTime = burnTime;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public boolean isBurning() {
+/* 69 */     return this.burning;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public void setBurning(boolean burning) {
+/* 78 */     this.burning = burning;
+/*    */   }
+/*    */   
+/*    */   public boolean isCancelled() {
+/* 82 */     return this.cancelled;
+/*    */   }
+/*    */   
+/*    */   public void setCancelled(boolean cancel) {
+/* 86 */     this.cancelled = cancel;
+/*    */   }
+/*    */ }
 
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.inventory.ItemStack;
-/**
- * Called when an ItemStack is successfully burned as fuel in a furnace.
- */
-public class FurnaceBurnEvent extends Event implements Cancellable {
-    private Block furnace;
-    private ItemStack fuel;
-    private int burnTime;
-    private boolean cancelled;
-    private boolean burning;
 
-    public FurnaceBurnEvent(Block furnace, ItemStack fuel, int burnTime) {
-        super(Type.FURNACE_BURN);
-
-        this.furnace = furnace;
-        this.fuel = fuel;
-        this.burnTime = burnTime;
-        this.cancelled = false;
-        this.burning = true;
-    }
-
-    /**
-     * Gets the block for the furnace involved in this event
-     *
-     * @return the block of the furnace
-     */
-    public Block getFurnace() {
-        return furnace;
-    }
-
-    /**
-     * Gets the fuel ItemStack for this event
-     *
-     * @return the fuel ItemStack
-     */
-    public ItemStack getFuel() {
-        return fuel;
-    }
-
-    /**
-     * Gets the burn time for this fuel
-     *
-     * @return the burn time for this fuel
-     */
-    public int getBurnTime() {
-        return burnTime;
-    }
-
-    /**
-     * Sets the burn time for this fuel
-     *
-     * @param burnTime the burn time for this fuel
-     */
-    public void setBurnTime(int burnTime) {
-        this.burnTime = burnTime;
-    }
-
-    /**
-     * Gets whether the furnace's fuel is burning or not.
-     *
-     * @return whether the furnace's fuel is burning or not.
-     */
-    public boolean isBurning() {
-        return this.burning;
-    }
-
-    /**
-     * Sets whether the furnace's fuel is burning or not.
-     *
-     * @param burning true if the furnace's fuel is burning
-     */
-    public void setBurning(boolean burning) {
-        this.burning = burning;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/event/inventory/FurnaceBurnEvent.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/inventory/FurnaceSmeltEvent.java b/src/main/java/org/bukkit/event/inventory/FurnaceSmeltEvent.java
index 4b42b46c..4363ebad 100644
--- a/src/main/java/org/bukkit/event/inventory/FurnaceSmeltEvent.java
+++ b/src/main/java/org/bukkit/event/inventory/FurnaceSmeltEvent.java
@@ -1,69 +1,75 @@
-package org.bukkit.event.inventory;
+/*    */ package org.bukkit.event.inventory;
+/*    */ 
+/*    */ import org.bukkit.block.Block;
+/*    */ import org.bukkit.event.Cancellable;
+/*    */ import org.bukkit.event.Event;
+/*    */ import org.bukkit.inventory.ItemStack;
+/*    */ 
+/*    */ public class FurnaceSmeltEvent
+/*    */   extends Event
+/*    */   implements Cancellable
+/*    */ {
+/*    */   private Block furnace;
+/*    */   private ItemStack source;
+/*    */   private ItemStack result;
+/*    */   private boolean cancelled;
+/*    */   
+/*    */   public FurnaceSmeltEvent(Block furnace, ItemStack source, ItemStack result) {
+/* 18 */     super(Event.Type.FURNACE_SMELT);
+/*    */     
+/* 20 */     this.furnace = furnace;
+/* 21 */     this.source = source;
+/* 22 */     this.result = result;
+/* 23 */     this.cancelled = false;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public Block getFurnace() {
+/* 32 */     return this.furnace;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public ItemStack getSource() {
+/* 41 */     return this.source;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public ItemStack getResult() {
+/* 50 */     return this.result;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public void setResult(ItemStack result) {
+/* 59 */     this.result = result;
+/*    */   }
+/*    */   
+/*    */   public boolean isCancelled() {
+/* 63 */     return this.cancelled;
+/*    */   }
+/*    */   
+/*    */   public void setCancelled(boolean cancel) {
+/* 67 */     this.cancelled = cancel;
+/*    */   }
+/*    */ }
 
-import org.bukkit.block.Block;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.inventory.ItemStack;
 
-/**
- * Called when an ItemStack is successfully smelted in a furnace.
- */
-public class FurnaceSmeltEvent extends Event implements Cancellable{
-    private Block furnace;
-    private ItemStack source;
-    private ItemStack result;
-    private boolean cancelled;
-
-    public FurnaceSmeltEvent(Block furnace, ItemStack source, ItemStack result) {
-        super(Type.FURNACE_SMELT);
-
-        this.furnace = furnace;
-        this.source = source;
-        this.result = result;
-        this.cancelled = false;
-    }
-
-    /**
-     * Gets the block for the furnace involved in this event
-     *
-     * @return the block of the furnace
-     */
-    public Block getFurnace() {
-        return furnace;
-    }
-
-    /**
-     * Gets the smelted ItemStack for this event
-     *
-     * @return smelting source ItemStack
-     */
-    public ItemStack getSource() {
-        return source;
-    }
-
-    /**
-     * Gets the resultant ItemStack for this event
-     *
-     * @return smelting result ItemStack
-     */
-    public ItemStack getResult() {
-        return result;
-    }
-
-    /**
-     * Sets the resultant ItemStack for this event
-     *
-     * @param result new result ItemStack
-     */
-    public void setResult(ItemStack result) {
-         this.result = result;
-    }
-
-    public boolean isCancelled() {
-        return cancelled;
-    }
-
-    public void setCancelled(boolean cancel) {
-        this.cancelled = cancel;
-    }
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/event/inventory/FurnaceSmeltEvent.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryListener.java b/src/main/java/org/bukkit/event/inventory/InventoryListener.java
index 83e7e6d5..d23ee38b 100644
--- a/src/main/java/org/bukkit/event/inventory/InventoryListener.java
+++ b/src/main/java/org/bukkit/event/inventory/InventoryListener.java
@@ -1,23 +1,15 @@
 package org.bukkit.event.inventory;
 
 import org.bukkit.event.Listener;
-/**
-* Handles all events thrown in relation to Blocks
- */
+
 public class InventoryListener implements Listener {
-    public InventoryListener() {}
+  public void onFurnaceSmelt(FurnaceSmeltEvent event) {}
+  
+  public void onFurnaceBurn(FurnaceBurnEvent event) {}
+}
 
-    /**
-     * Called when an ItemStack is successfully smelted in a furnace.
-     *
-     * @param event Relevant event details
-     */
-    public void onFurnaceSmelt(FurnaceSmeltEvent event) {}
 
-    /**
-     * Called when an ItemStack is successfully burned as fuel in a furnace.
-     *
-     * @param event Relevant event details
-     */
-    public void onFurnaceBurn(FurnaceBurnEvent event) {}
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/event/inventory/InventoryListener.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/event/inventory/InventoryType.java b/src/main/java/org/bukkit/event/inventory/InventoryType.java
new file mode 100644
index 00000000..e9507696
--- /dev/null
+++ b/src/main/java/org/bukkit/event/inventory/InventoryType.java
@@ -0,0 +1,119 @@
+package org.bukkit.event.inventory;
+
+public enum InventoryType {
+
+    /**
+     * A chest inventory, with 0, 9, 18, 27, 36, 45, or 54 slots of type CONTAINER.
+     */
+    CHEST(27,"Chest"),
+    /**
+     * A dispenser inventory, with 9 slots of type CONTAINER.
+     */
+    DISPENSER(9,"Dispenser"),
+    /**
+     * A dropper inventory, with 9 slots of type CONTAINER.
+     */
+    /*DROPPER(9, "Dropper"),
+    /**
+     * A furnace inventory, with a RESULT slot, a CRAFTING slot, and a FUEL slot.
+     */
+    FURNACE(3,"Furnace"),
+    /**
+     * A workbench inventory, with 9 CRAFTING slots and a RESULT slot.
+     */
+    WORKBENCH(10,"Crafting"),
+    /**
+     * A player's crafting inventory, with 4 CRAFTING slots and a RESULT slot. Also implies that the
+     * 4 ARMOR slots are accessible.
+     */
+    CRAFTING(5,"Crafting"),
+    /**
+     * An enchantment table inventory, with one CRAFTING slot and three enchanting buttons.
+     */
+    /*ENCHANTING(1,"Enchanting"),
+    /**
+     * A brewing stand inventory, with one FUEL slot and three CRAFTING slots.
+     */
+    /*BREWING(4,"Brewing"),
+    /**
+     * A player's inventory, with 9 QUICKBAR slots, 27 CONTAINER slots, and 4 ARMOR slots. The
+     * ARMOUR slots may not be visible to the player, though.
+     */
+    PLAYER(36,"Player"),
+    /**
+     * The creative mode inventory, with only 9 QUICKBAR slots and nothing else. (The actual
+     * creative interface with the items is client-side and cannot be altered by the server.)
+     */
+    /*CREATIVE(9,"Creative"),
+    /**
+     * The merchant inventory, with 2 TRADE-IN slots, and 1 RESULT slot.
+     */
+    /*MERCHANT(3,"Villager"),
+    /**
+     * The ender chest inventory, with 27 slots.
+     */
+    /*ENDER_CHEST(27,"Ender Chest"),
+    /**
+     * An anvil inventory, with 2 CRAFTING slots and 1 RESULT slot
+     */
+    /*ANVIL(3, "Repairing"),
+    /**
+     * A beacon inventory, with 1 CRAFTING slot
+     */
+    /*BEACON(1, "container.beacon"),
+    /**
+     * A hopper inventory, with 5 slots of type CONTAINER.
+     */
+    /*HOPPER(5, "Item Hopper"),*/
+    ;
+
+    private final int size;
+    private final String title;
+
+    private InventoryType(int defaultSize, String defaultTitle) {
+        size = defaultSize;
+        title = defaultTitle;
+    }
+
+    public int getDefaultSize() {
+        return size;
+    }
+
+    public String getDefaultTitle() {
+        return title;
+    }
+
+    public enum SlotType {
+        /**
+         * A result slot in a furnace or crafting inventory.
+         */
+        RESULT,
+        /**
+         * A slot in the crafting matrix, or the input slot in a furnace inventory,
+         * the potion slot in the brewing stand, or the enchanting slot.
+         */
+        CRAFTING,
+        /**
+         * An armour slot in the player's inventory.
+         */
+        ARMOR,
+        /**
+         * A regular slot in the container or the player's inventory; anything not covered
+         * by the other enum values.
+         */
+        CONTAINER,
+        /**
+         * A slot in the bottom row or quickbar.
+         */
+        QUICKBAR,
+        /**
+         * A pseudo-slot representing the area outside the inventory window.
+         */
+        OUTSIDE,
+        /**
+         * The fuel slot in a furnace inventory, or the ingredient slot in a brewing stand inventory.
+         */
+        FUEL;
+    }
+}
+
diff --git a/src/main/java/org/bukkit/inventory/FurnaceRecipe.java b/src/main/java/org/bukkit/inventory/FurnaceRecipe.java
index 50c4cc71..784208bd 100644
--- a/src/main/java/org/bukkit/inventory/FurnaceRecipe.java
+++ b/src/main/java/org/bukkit/inventory/FurnaceRecipe.java
@@ -1,73 +1,79 @@
-package org.bukkit.inventory;
+/*    */ package org.bukkit.inventory;
+/*    */ 
+/*    */ import org.bukkit.Material;
+/*    */ import org.bukkit.material.MaterialData;
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ public class FurnaceRecipe
+/*    */   implements Recipe
+/*    */ {
+/*    */   private ItemStack output;
+/*    */   private MaterialData ingredient;
+/*    */   
+/*    */   public FurnaceRecipe(ItemStack result, Material source) {
+/* 19 */     this(result, source.getNewData((byte)0));
+/* 20 */     if (this.ingredient == null) {
+/* 21 */       setInput(new MaterialData(source));
+/*    */     }
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public FurnaceRecipe(ItemStack result, MaterialData source) {
+/* 31 */     this.output = result;
+/* 32 */     this.ingredient = source;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public FurnaceRecipe setInput(MaterialData input) {
+/* 41 */     this.ingredient = input;
+/* 42 */     return this;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public FurnaceRecipe setInput(Material input) {
+/* 51 */     setInput(input.getNewData((byte)0));
+/* 52 */     if (this.ingredient == null) {
+/* 53 */       setInput(new MaterialData(input));
+/*    */     }
+/* 55 */     return this;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public MaterialData getInput() {
+/* 63 */     return this.ingredient;
+/*    */   }
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */ 
+/*    */   
+/*    */   public ItemStack getResult() {
+/* 71 */     return this.output;
+/*    */   }
+/*    */ }
 
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
 
-/**
- * Represents a smelting recipe.
- */
-public class FurnaceRecipe implements Recipe {
-    private ItemStack output;
-    private MaterialData ingredient;
-
-    /**
-     * Create a furnace recipe to craft the specified ItemStack.
-     * @param result The item you want the recipe to create.
-     * @param source The input material.
-     */
-    public FurnaceRecipe(ItemStack result, Material source) {
-        this(result, source.getNewData((byte) 0));
-        if (this.ingredient == null) {
-            setInput(new MaterialData(source));
-        }
-    }
-
-    /**
-     * Create a furnace recipe to craft the specified ItemStack.
-     * @param result The item you want the recipe to create.
-     * @param source The input material.
-     */
-    public FurnaceRecipe(ItemStack result, MaterialData source) {
-        this.output = result;
-        this.ingredient = source;
-    }
-
-    /**
-     * Sets the input of this furnace recipe.
-     * @param input The input material.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public FurnaceRecipe setInput(MaterialData input) {
-        this.ingredient = input;
-        return this;
-    }
-
-    /**
-     * Sets the input of this furnace recipe.
-     * @param input The input material.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public FurnaceRecipe setInput(Material input) {
-        setInput(input.getNewData((byte) 0));
-        if (this.ingredient == null) {
-            setInput(new MaterialData(input));
-        }
-        return this;
-    }
-
-    /**
-     * Get the input material.
-     * @return The input material.
-     */
-    public MaterialData getInput() {
-        return (MaterialData) ingredient;
-    }
-
-    /**
-     * Get the result of this recipe.
-     * @return The resulting stack.
-     */
-    public ItemStack getResult() {
-        return output;
-    }
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/FurnaceRecipe.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/Inventory.java b/src/main/java/org/bukkit/inventory/Inventory.java
index 81cebe82..b45f7abe 100644
--- a/src/main/java/org/bukkit/inventory/Inventory.java
+++ b/src/main/java/org/bukkit/inventory/Inventory.java
@@ -3,216 +3,62 @@ package org.bukkit.inventory;
 import java.util.HashMap;
 import org.bukkit.Material;
 
-/**
- * Interface to the various inventories
- */
 public interface Inventory {
+  int getSize();
+  
+  String getName();
+  
+  ItemStack getItem(int paramInt);
+  
+  void setItem(int paramInt, ItemStack paramItemStack);
+  
+  HashMap<Integer, ItemStack> addItem(ItemStack... paramVarArgs);
+  
+  HashMap<Integer, ItemStack> removeItem(ItemStack... paramVarArgs);
+  
+  ItemStack[] getContents();
+  
+  void setContents(ItemStack[] paramArrayOfItemStack);
+  
+  boolean contains(int paramInt);
+  
+  boolean contains(Material paramMaterial);
+  
+  boolean contains(ItemStack paramItemStack);
+  
+  boolean contains(int paramInt1, int paramInt2);
+  
+  boolean contains(Material paramMaterial, int paramInt);
+  
+  boolean contains(ItemStack paramItemStack, int paramInt);
+  
+  HashMap<Integer, ? extends ItemStack> all(int paramInt);
+  
+  HashMap<Integer, ? extends ItemStack> all(Material paramMaterial);
+  
+  HashMap<Integer, ? extends ItemStack> all(ItemStack paramItemStack);
+  
+  int first(int paramInt);
+  
+  int first(Material paramMaterial);
+  
+  int first(ItemStack paramItemStack);
+  
+  int firstEmpty();
+  
+  void remove(int paramInt);
+  
+  void remove(Material paramMaterial);
+  
+  void remove(ItemStack paramItemStack);
+  
+  void clear(int paramInt);
+  
+  void clear();
+}
 
-    /**
-     * Returns the size of the inventory
-     *
-     * @return The inventory size
-     */
-    public int getSize();
-
-    /**
-     * Return the name of the inventory
-     *
-     * @return The inventory name
-     */
-    public String getName();
-
-    /**
-     * Get the ItemStack found in the slot at the given index
-     *
-     * @param index The index of the Slot's ItemStack to return
-     * @return The ItemStack in the slot
-     */
-    public ItemStack getItem(int index);
-
-    /**
-     * Stores the ItemStack at the given index
-     *
-     * @param index The index where to put the ItemStack
-     * @param item The ItemStack to set
-     */
-    public void setItem(int index, ItemStack item);
-
-    /**
-     * Stores the given ItemStacks in the inventory.
-     *
-     * This will try to fill existing stacks and empty slots as good as it can.
-     * It will return a HashMap of what it couldn't fit.
-     *
-     * @param items The ItemStacks to add
-     * @return
-     */
-    public HashMap<Integer, ItemStack> addItem(ItemStack... items);
-
-    /**
-     * Removes the given ItemStacks from the inventory.
-     *
-     * It will try to remove 'as much as possible' from the types and amounts you
-     * give as arguments. It will return a HashMap of what it couldn't remove.
-     *
-     * @param items The ItemStacks to remove
-     * @return
-     */
-    public HashMap<Integer, ItemStack> removeItem(ItemStack... items);
-
-    /**
-     * Get all ItemStacks from the inventory
-     *
-     * @return All the ItemStacks from all slots
-     */
-    public ItemStack[] getContents();
-
-    /**
-     * Set the inventory's contents
-     *
-     * @return All the ItemStacks from all slots
-     */
-    public void setContents(ItemStack[] items);
-
-    /**
-     * Check if the inventory contains any ItemStacks with the given materialId
-     *
-     * @param materialId The materialId to check for
-     * @return If any ItemStacks were found
-     */
-    public boolean contains(int materialId);
-
-    /**
-     * Check if the inventory contains any ItemStacks with the given material
-     *
-     * @param material The material to check for
-     * @return If any ItemStacks were found
-     */
-    public boolean contains(Material material);
-
-    /**
-     * Check if the inventory contains any ItemStacks matching the given ItemStack
-     * This will only match if both the type and the amount of the stack match
-     *
-     * @param item The ItemStack to match against
-     * @return If any matching ItemStacks were found
-     */
-    public boolean contains(ItemStack item);
-
-    /**
-     * Check if the inventory contains any ItemStacks with the given materialId and at least the minimum amount specified
-     *
-     * @param materialId The materialId to check for
-     * @param amount The minimum amount to look for
-     * @return If any ItemStacks were found
-     */
-    public boolean contains(int materialId, int amount);
-
-    /**
-     * Check if the inventory contains any ItemStacks with the given material and at least the minimum amount specified
-     *
-     * @param material The material to check for
-     * @return If any ItemStacks were found
-     */
-    public boolean contains(Material material, int amount);
-
-    /**
-     * Check if the inventory contains any ItemStacks matching the given ItemStack and at least the minimum amount specified
-     * This will only match if both the type and the amount of the stack match
-     *
-     * @param item The ItemStack to match against
-     * @return If any matching ItemStacks were found
-     */
-    public boolean contains(ItemStack item, int amount);
-
-    /**
-     * Find all slots in the inventory containing any ItemStacks with the given materialId
-     *
-     * @param materialId The materialId to look for
-     * @return The Slots found.
-     */
-    public HashMap<Integer, ? extends ItemStack> all(int materialId);
-
-    /**
-     * Find all slots in the inventory containing any ItemStacks with the given material
-     *
-     * @param materialId The material to look for
-     * @return The Slots found.
-     */
-    public HashMap<Integer, ? extends ItemStack> all(Material material);
-
-    /**
-     * Find all slots in the inventory containing any ItemStacks with the given ItemStack
-     * This will only match slots if both the type and the amount of the stack match
-     *
-     * @param item The ItemStack to match against
-     * @return The Slots found.
-     */
-    public HashMap<Integer, ? extends ItemStack> all(ItemStack item);
-
-    /**
-     * Find the first slot in the inventory containing an ItemStack with the given materialId
-     *
-     * @param materialId The materialId to look for
-     * @return The Slot found.
-     */
-    public int first(int materialId);
-
-    /**
-     * Find the first slot in the inventory containing an ItemStack with the given material
-     *
-     * @param materialId The material to look for
-     * @return The Slot found.
-     */
-    public int first(Material material);
-
-    /**
-     * Find the first slot in the inventory containing an ItemStack with the given stack
-     * This will only match a slot if both the type and the amount of the stack match
-     *
-     * @param item The ItemStack to match against
-     * @return The Slot found.
-     */
-    public int first(ItemStack item);
-
-    /**
-     * Find the first empty Slot.
-     *
-     * @return The first empty Slot found.
-     */
-    public int firstEmpty();
-
-    /**
-     * Remove all stacks in the inventory matching the given materialId.
-     *
-     * @param materialId The material to remove
-     */
-    public void remove(int materialId);
-
-    /**
-     * Remove all stacks in the inventory matching the given material.
-     *
-     * @param material The material to remove
-     */
-    public void remove(Material material);
-
-    /**
-     * Remove all stacks in the inventory matching the given stack.
-     * This will only match a slot if both the type and the amount of the stack match
-     *
-     * @param item The ItemStack to match against
-     */
-    public void remove(ItemStack item);
-
-    /**
-     * Clear out a particular slot in the index
-     *
-     * @param index The index to empty.
-     */
-    public void clear(int index);
 
-    /**
-     * Clear out the whole index
-     */
-    public void clear();
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/Inventory.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/InventoryHolder.java b/src/main/java/org/bukkit/inventory/InventoryHolder.java
new file mode 100644
index 00000000..0bc23c58
--- /dev/null
+++ b/src/main/java/org/bukkit/inventory/InventoryHolder.java
@@ -0,0 +1,13 @@
+package org.bukkit.inventory;
+
+import org.bukkit.inventory.Inventory;
+
+public interface InventoryHolder {
+
+    /**
+     * Get the object's inventory.
+     *
+     * @return The inventory.
+     */
+    public Inventory getInventory();
+}
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index 8c9fc1cb..67b216d7 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -1,211 +1,217 @@
-package org.bukkit.inventory;
-
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a stack of items
- */
-public class ItemStack {
-    private int type;
-    private int amount = 0;
-    private MaterialData data = null;
-    private short durability = 0;
-
-    public ItemStack(final int type) {
-        this(type, 0);
-    }
-
-    public ItemStack(final Material type) {
-        this(type, 0);
-    }
-
-    public ItemStack(final int type, final int amount) {
-        this(type, amount, (short) 0);
-    }
-
-    public ItemStack(final Material type, final int amount) {
-        this(type.getId(), amount);
-    }
-
-    public ItemStack(final int type, final int amount, final short damage) {
-        this(type, amount, damage, null);
-    }
-
-    public ItemStack(final Material type, final int amount, final short damage) {
-        this(type.getId(), amount, damage);
-    }
-
-    public ItemStack(final int type, final int amount, final short damage, final Byte data) {
-        this.type = type;
-        this.amount = amount;
-        this.durability = damage;
-        if (data != null) {
-            createData(data);
-            this.durability = data;
-        }
-    }
-
-    public ItemStack(final Material type, final int amount, final short damage, final Byte data) {
-        this(type.getId(), amount, damage, data);
-    }
-
-    /**
-     * Gets the type of this item
-     *
-     * @return Type of the items in this stack
-     */
-    public Material getType() {
-        return Material.getMaterial(type);
-    }
-
-    /**
-     * Sets the type of this item<br />
-     * <br />
-     * Note that in doing so you will reset the MaterialData for this stack
-     *
-     * @param type New type to set the items in this stack to
-     */
-    public void setType(Material type) {
-        setTypeId(type.getId());
-    }
-
-    /**
-     * Gets the type id of this item
-     *
-     * @return Type Id of the items in this stack
-     */
-    public int getTypeId() {
-        return type;
-    }
-
-    /**
-     * Sets the type id of this item<br />
-     * <br />
-     * Note that in doing so you will reset the MaterialData for this stack
-     *
-     * @param type New type id to set the items in this stack to
-     */
-    public void setTypeId(int type) {
-        this.type = type;
-        createData((byte) 0);
-    }
-
-    /**
-     * Gets the amount of items in this stack
-     *
-     * @return Amount of items in this stick
-     */
-    public int getAmount() {
-        return amount;
-    }
-
-    /**
-     * Sets the amount of items in this stack
-     *
-     * @param amount New amount of items in this stack
-     */
-    public void setAmount(int amount) {
-        this.amount = amount;
-    }
-
-    /**
-     * Gets the MaterialData for this stack of items
-     *
-     * @return MaterialData for this item
-     */
-    public MaterialData getData() {
-        if (Material.getMaterial(getTypeId()).getData() != null) {
-            data = Material.getMaterial(getTypeId()).getNewData((byte) this.durability);
-        }
-
-        return data;
-    }
-
-    /**
-     * Sets the MaterialData for this stack of items
-     *
-     * @param amount New MaterialData for this item
-     */
-    public void setData(MaterialData data) {
-        Material mat = getType();
-
-        if ((mat == null) || (mat.getData() == null)) {
-            this.data = data;
-        } else {
-            if ((data.getClass() == mat.getData()) || (data.getClass() == MaterialData.class)) {
-                this.data = data;
-            } else {
-                throw new IllegalArgumentException("Provided data is not of type " + mat.getData().getName() + ", found " + data.getClass().getName());
-            }
-        }
-    }
-
-    /**
-     * Sets the durability of this item
-     *
-     * @param durability Durability of this item
-     */
-    public void setDurability(final short durability) {
-        this.durability = durability;
-    }
-
-    /**
-     * Gets the durability of this item
-     *
-     * @return Durability of this item
-     */
-    public short getDurability() {
-        return durability;
-    }
-
-    /**
-     * Get the maximum stacksize for the material hold in this ItemStack
-     * Returns -1 if it has no idea.
-     *
-     * @return The maximum you can stack this material to.
-     */
-    public int getMaxStackSize() {
-        return -1;
-    }
-
-    private void createData(final byte data) {
-        Material mat = Material.getMaterial(type);
-
-        if (mat == null) {
-            this.data = new MaterialData(type, data);
-        } else {
-            this.data = mat.getNewData(data);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return "ItemStack{" + getType().name() + " x " + getAmount() + "}";
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (!(obj instanceof ItemStack)) {
-            return false;
-        }
-
-        ItemStack item = (ItemStack) obj;
-
-        return item.getAmount() == getAmount() && item.getTypeId() == getTypeId();
-    }
-
-    @Override
-    public ItemStack clone() {
-        return new ItemStack(type, amount, durability);
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 11;
-
-        hash = hash * 19 + 7 * getTypeId(); // Overriding hashCode since equals is overridden, it's just
-        hash = hash * 7 + 23 * getAmount(); // too bad these are mutable values... Q_Q
-        return hash;
-    }
-}
+/*     */ package org.bukkit.inventory;
+/*     */ 
+/*     */ import org.bukkit.Material;
+/*     */ import org.bukkit.material.MaterialData;
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ public class ItemStack
+/*     */ {
+/*     */   private int type;
+/*  11 */   private int amount = 0;
+/*  12 */   private MaterialData data = null;
+/*  13 */   private short durability = 0;
+/*     */   
+/*     */   public ItemStack(int type) {
+/*  16 */     this(type, 0);
+/*     */   }
+/*     */   
+/*     */   public ItemStack(Material type) {
+/*  20 */     this(type, 0);
+/*     */   }
+/*     */   
+/*     */   public ItemStack(int type, int amount) {
+/*  24 */     this(type, amount, (short)0);
+/*     */   }
+/*     */   
+/*     */   public ItemStack(Material type, int amount) {
+/*  28 */     this(type.getId(), amount);
+/*     */   }
+/*     */   
+/*     */   public ItemStack(int type, int amount, short damage) {
+/*  32 */     this(type, amount, damage, (Byte)null);
+/*     */   }
+/*     */   
+/*     */   public ItemStack(Material type, int amount, short damage) {
+/*  36 */     this(type.getId(), amount, damage);
+/*     */   }
+/*     */   
+/*     */   public ItemStack(int type, int amount, short damage, Byte data) {
+/*  40 */     this.type = type;
+/*  41 */     this.amount = amount;
+/*  42 */     this.durability = damage;
+/*  43 */     if (data != null) {
+/*  44 */       createData(data.byteValue());
+/*  45 */       this.durability = (short)data.byteValue();
+/*     */     } 
+/*     */   }
+/*     */   
+/*     */   public ItemStack(Material type, int amount, short damage, Byte data) {
+/*  50 */     this(type.getId(), amount, damage, data);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public Material getType() {
+/*  59 */     return Material.getMaterial(this.type);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public void setType(Material type) {
+/*  70 */     setTypeId(type.getId());
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public int getTypeId() {
+/*  79 */     return this.type;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public void setTypeId(int type) {
+/*  90 */     this.type = type;
+/*  91 */     createData((byte)0);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public int getAmount() {
+/* 100 */     return this.amount;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public void setAmount(int amount) {
+/* 109 */     this.amount = amount;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public MaterialData getData() {
+/* 118 */     if (Material.getMaterial(getTypeId()).getData() != null) {
+/* 119 */       this.data = Material.getMaterial(getTypeId()).getNewData((byte)this.durability);
+/*     */     }
+/*     */     
+/* 122 */     return this.data;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public void setData(MaterialData data) {
+/* 131 */     Material mat = getType();
+/*     */     
+/* 133 */     if (mat == null || mat.getData() == null) {
+/* 134 */       this.data = data;
+/*     */     }
+/* 136 */     else if (data.getClass() == mat.getData() || data.getClass() == MaterialData.class) {
+/* 137 */       this.data = data;
+/*     */     } else {
+/* 139 */       throw new IllegalArgumentException("Provided data is not of type " + mat.getData().getName() + ", found " + data.getClass().getName());
+/*     */     } 
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public void setDurability(short durability) {
+/* 150 */     this.durability = durability;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public short getDurability() {
+/* 159 */     return this.durability;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public int getMaxStackSize() {
+/* 169 */     return -1;
+/*     */   }
+/*     */   
+/*     */   private void createData(byte data) {
+/* 173 */     Material mat = Material.getMaterial(this.type);
+/*     */     
+/* 175 */     if (mat == null) {
+/* 176 */       this.data = new MaterialData(this.type, data);
+/*     */     } else {
+/* 178 */       this.data = mat.getNewData(data);
+/*     */     } 
+/*     */   }
+/*     */ 
+/*     */   
+/*     */   public String toString() {
+/* 184 */     return "ItemStack{" + getType().name() + " x " + getAmount() + "}";
+/*     */   }
+/*     */ 
+/*     */   
+/*     */   public boolean equals(Object obj) {
+/* 189 */     if (!(obj instanceof ItemStack)) {
+/* 190 */       return false;
+/*     */     }
+/*     */     
+/* 193 */     ItemStack item = (ItemStack)obj;
+/*     */     
+/* 195 */     return (item.getAmount() == getAmount() && item.getTypeId() == getTypeId());
+/*     */   }
+/*     */ 
+/*     */   
+/*     */   public ItemStack clone() {
+/* 200 */     return new ItemStack(this.type, this.amount, this.durability);
+/*     */   }
+/*     */ 
+/*     */   
+/*     */   public int hashCode() {
+/* 205 */     int hash = 11;
+/*     */     
+/* 207 */     hash = hash * 19 + 7 * getTypeId();
+/* 208 */     hash = hash * 7 + 23 * getAmount();
+/* 209 */     return hash;
+/*     */   }
+/*     */ }
+
+
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/ItemStack.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/PlayerInventory.java b/src/main/java/org/bukkit/inventory/PlayerInventory.java
index db655bce..df14d9ae 100644
--- a/src/main/java/org/bukkit/inventory/PlayerInventory.java
+++ b/src/main/java/org/bukkit/inventory/PlayerInventory.java
@@ -1,102 +1,35 @@
 package org.bukkit.inventory;
 
-/**
- * Includes interface to the 4 armor slots
- */
 public interface PlayerInventory extends Inventory {
+  ItemStack[] getArmorContents();
+  
+  ItemStack getHelmet();
+  
+  ItemStack getChestplate();
+  
+  ItemStack getLeggings();
+  
+  ItemStack getBoots();
+  
+  void setArmorContents(ItemStack[] paramArrayOfItemStack);
+  
+  void setHelmet(ItemStack paramItemStack);
+  
+  void setChestplate(ItemStack paramItemStack);
+  
+  void setLeggings(ItemStack paramItemStack);
+  
+  void setBoots(ItemStack paramItemStack);
+  
+  ItemStack getItemInHand();
+  
+  void setItemInHand(ItemStack paramItemStack);
+  
+  int getHeldItemSlot();
+}
 
-    /**
-     * Get all ItemStacks from the armor slots
-     *
-     * @return All the ItemStacks from the armor slots
-     */
-    public ItemStack[] getArmorContents();
-
-    /**
-     * Return the ItemStack from the helmet slot
-     *
-     * @return The ItemStack in the helmet slot
-     */
-    public ItemStack getHelmet();
-
-    /**
-     * Return the ItemStack from the chestplate slot
-     *
-     * @return The ItemStack in the chestplate slot
-     */
-    public ItemStack getChestplate();
-
-    /**
-     * Return the ItemStack from the leg slot
-     *
-     * @return The ItemStack in the leg slot
-     */
-    public ItemStack getLeggings();
-
-    /**
-     * Return the ItemStack from the boots slot
-     *
-     * @return The ItemStack in the boots slot
-     */
-    public ItemStack getBoots();
-
-    /**
-     * Put the given ItemStacks into the armor slots
-     *
-     *  @param items The ItemStacks to use as armour
-     */
-    public void setArmorContents(ItemStack[] items);
-
-    /**
-     * Put the given ItemStack into the helmet slot
-     * This does not check if the ItemStack is a helmet
-     *
-     * @param helmet The ItemStack to use as helmet
-     */
-    public void setHelmet(ItemStack helmet);
-
-    /**
-     * Put the given ItemStack into the chestplate slot
-     * This does not check if the ItemStack is a chestplate
-     *
-     * @param chestplate The ItemStack to use as chestplate
-     */
-    public void setChestplate(ItemStack chestplate);
-
-    /**
-     * Put the given ItemStack into the leg slot
-     * This does not check if the ItemStack is a pair of leggings
-     *
-     * @param leggings The ItemStack to use as leggings
-     */
-    public void setLeggings(ItemStack leggings);
-
-    /**
-     * Put the given ItemStack into the boots slot
-     * This does not check if the ItemStack is a boots
-     *
-     * @param boots The ItemStack to use as boots
-     */
-    public void setBoots(ItemStack boots);
-
-    /**
-     * Returns the ItemStack currently hold
-     *
-     * @return The currently held ItemStack
-     */
-    public ItemStack getItemInHand();
-
-    /**
-     * Sets the item in hand
-     *
-     * @param stack Stack to set
-     */
-    public void setItemInHand(ItemStack stack);
 
-    /**
-     * Get the slot number of the currently held item
-     *
-     * @return Held item slot number
-     */
-    public int getHeldItemSlot();
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/PlayerInventory.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/Recipe.java b/src/main/java/org/bukkit/inventory/Recipe.java
index 7a019853..bd75c835 100644
--- a/src/main/java/org/bukkit/inventory/Recipe.java
+++ b/src/main/java/org/bukkit/inventory/Recipe.java
@@ -1,13 +1,11 @@
 package org.bukkit.inventory;
 
-/**
- * Represents some type of crafting recipe.
- */
 public interface Recipe {
-
-    /**
-     * Get the result of this recipe.
-     * @return The result stack
-     */
-    ItemStack getResult();
+  ItemStack getResult();
 }
+
+
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/Recipe.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/ShapedRecipe.java b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
index 9df52a87..49354aef 100644
--- a/src/main/java/org/bukkit/inventory/ShapedRecipe.java
+++ b/src/main/java/org/bukkit/inventory/ShapedRecipe.java
@@ -1,132 +1,138 @@
-package org.bukkit.inventory;
-
-import java.util.HashMap;
-
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a shaped (ie normal) crafting recipe.
- */
-public class ShapedRecipe implements Recipe {
-    private ItemStack output;
-    private String[] rows;
-    private HashMap<Character, MaterialData> ingredients = new HashMap<Character, MaterialData>();
-
-    /**
-     * Create a shaped recipe to craft the specified ItemStack. The constructor merely determines the
-     * result and type; to set the actual recipe, you'll need to call the appropriate methods.
-     * @param result The item you want the recipe to create.
-     * @see ShapedRecipe#shape(String...)
-     * @see ShapedRecipe#setIngredient(char, Material)
-     * @see ShapedRecipe#setIngredient(char, Material, int)
-     * @see ShapedRecipe#setIngredient(char, MaterialData)
-     */
-    public ShapedRecipe(ItemStack result) {
-        this.output = result;
-    }
-
-    /**
-     * Set the shape of this recipe to the specified rows. Each character represents a different
-     * ingredient; exactly what each character represents is set separately.
-     * @param shape The rows of the recipe (up to 3 rows).
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapedRecipe shape(String... shape) {
-        if (shape == null || shape.length > 3 || shape.length < 1) {
-            throw new IllegalArgumentException("Crafting recipes should be 1, 2, or 3 rows.");
-        }
-        for (String row : shape) {
-            if (row == null || row.length() > 3 || row.length() < 1) {
-                throw new IllegalArgumentException("Crafting rows should be 1, 2, or 3 characters.");
-            }
-        }
-        this.rows = shape;
-
-        // Remove character mappings for characters that no longer exist in the shape
-        HashMap<Character, MaterialData> ingredientsTemp = this.ingredients;
-
-        this.ingredients = new HashMap<Character, MaterialData>();
-        for (char key : ingredientsTemp.keySet()) {
-            try {
-                setIngredient(key, ingredientsTemp.get(key));
-            } catch (IllegalArgumentException e) {}
-        }
-        return this;
-    }
-
-    /**
-     * Sets the material that a character in the recipe shape refers to.
-     * @param key The character that represents the ingredient in the shape.
-     * @param ingredient The ingredient.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapedRecipe setIngredient(char key, MaterialData ingredient) {
-        if (!hasKey(key)) {
-            throw new IllegalArgumentException("Symbol " + key + " does not appear in the shape.");
-        }
-        ingredients.put(key, ingredient);
-        return this;
-    }
-
-    /**
-     * Sets the material that a character in the recipe shape refers to.
-     * @param key The character that represents the ingredient in the shape.
-     * @param ingredient The ingredient.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapedRecipe setIngredient(char key, Material ingredient) {
-        return setIngredient(key, ingredient, 0);
-    }
-
-    /**
-     * Sets the material that a character in the recipe shape refers to.
-     * @param key The character that represents the ingredient in the shape.
-     * @param ingredient The ingredient.
-     * @param raw The raw material data as an integer.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapedRecipe setIngredient(char key, Material ingredient, int raw) {
-        MaterialData data = ingredient.getNewData((byte) raw);
-
-        if (data == null) {
-            data = new MaterialData(ingredient, (byte) raw);
-        }
-        return setIngredient(key, data);
-    }
-
-    private boolean hasKey(char c) {
-        String key = Character.toString(c);
-
-        for (String row : rows) {
-            if (row.contains(key)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Get the ingredients map.
-     * @return The mapping of character to ingredients.
-     */
-    public HashMap<Character, MaterialData> getIngredientMap() {
-        return ingredients;
-    }
-
-    /**
-     * Get the shape.
-     * @return The recipe's shape.
-     */
-    public String[] getShape() {
-        return rows;
-    }
-
-    /**
-     * Get the result.
-     * @return The result stack.
-     */
-    public ItemStack getResult() {
-        return output;
-    }
-}
+/*     */ package org.bukkit.inventory;
+/*     */ 
+/*     */ import java.util.HashMap;
+/*     */ import java.util.Iterator;
+/*     */ import org.bukkit.Material;
+/*     */ import org.bukkit.material.MaterialData;
+/*     */ 
+/*     */ 
+/*     */ public class ShapedRecipe
+/*     */   implements Recipe
+/*     */ {
+/*     */   private ItemStack output;
+/*     */   private String[] rows;
+/*  14 */   private HashMap<Character, MaterialData> ingredients = new HashMap<>();
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapedRecipe(ItemStack result) {
+/*  26 */     this.output = result;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapedRecipe shape(String... shape) {
+/*  36 */     if (shape == null || shape.length > 3 || shape.length < 1) {
+/*  37 */       throw new IllegalArgumentException("Crafting recipes should be 1, 2, or 3 rows.");
+/*     */     }
+/*  39 */     for (String row : shape) {
+/*  40 */       if (row == null || row.length() > 3 || row.length() < 1) {
+/*  41 */         throw new IllegalArgumentException("Crafting rows should be 1, 2, or 3 characters.");
+/*     */       }
+/*     */     } 
+/*  44 */     this.rows = shape;
+/*     */ 
+/*     */     
+/*  47 */     HashMap<Character, MaterialData> ingredientsTemp = this.ingredients;
+/*     */     
+/*  49 */     this.ingredients = new HashMap<>();
+/*  50 */     for (Iterator<Character> iterator = ingredientsTemp.keySet().iterator(); iterator.hasNext(); ) { char key = ((Character)iterator.next()).charValue();
+/*     */       try {
+/*  52 */         setIngredient(key, ingredientsTemp.get(Character.valueOf(key)));
+/*  53 */       } catch (IllegalArgumentException illegalArgumentException) {} }
+/*     */     
+/*  55 */     return this;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapedRecipe setIngredient(char key, MaterialData ingredient) {
+/*  65 */     if (!hasKey(key)) {
+/*  66 */       throw new IllegalArgumentException("Symbol " + key + " does not appear in the shape.");
+/*     */     }
+/*  68 */     this.ingredients.put(Character.valueOf(key), ingredient);
+/*  69 */     return this;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapedRecipe setIngredient(char key, Material ingredient) {
+/*  79 */     return setIngredient(key, ingredient, 0);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapedRecipe setIngredient(char key, Material ingredient, int raw) {
+/*  90 */     MaterialData data = ingredient.getNewData((byte)raw);
+/*     */     
+/*  92 */     if (data == null) {
+/*  93 */       data = new MaterialData(ingredient, (byte)raw);
+/*     */     }
+/*  95 */     return setIngredient(key, data);
+/*     */   }
+/*     */   
+/*     */   private boolean hasKey(char c) {
+/*  99 */     String key = Character.toString(c);
+/*     */     
+/* 101 */     for (String row : this.rows) {
+/* 102 */       if (row.contains(key)) {
+/* 103 */         return true;
+/*     */       }
+/*     */     } 
+/* 106 */     return false;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public HashMap<Character, MaterialData> getIngredientMap() {
+/* 114 */     return this.ingredients;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public String[] getShape() {
+/* 122 */     return this.rows;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ItemStack getResult() {
+/* 130 */     return this.output;
+/*     */   }
+/*     */ }
+
+
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/ShapedRecipe.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/ShapelessRecipe.java b/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
index 4cb92668..4e639ad1 100644
--- a/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
+++ b/src/main/java/org/bukkit/inventory/ShapelessRecipe.java
@@ -1,123 +1,129 @@
-package org.bukkit.inventory;
+/*     */ package org.bukkit.inventory;
+/*     */ 
+/*     */ import java.util.ArrayList;
+/*     */ import org.bukkit.Material;
+/*     */ import org.bukkit.material.MaterialData;
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ public class ShapelessRecipe
+/*     */   implements Recipe
+/*     */ {
+/*     */   private ItemStack output;
+/*  14 */   private ArrayList<MaterialData> ingredients = new ArrayList<>();
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe(ItemStack result) {
+/*  24 */     this.output = result;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe addIngredient(MaterialData ingredient) {
+/*  33 */     return addIngredient(1, ingredient);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe addIngredient(Material ingredient) {
+/*  42 */     return addIngredient(1, ingredient, 0);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe addIngredient(Material ingredient, int rawdata) {
+/*  52 */     return addIngredient(1, ingredient, rawdata);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe addIngredient(int count, MaterialData ingredient) {
+/*  62 */     if (this.ingredients.size() + count > 9) {
+/*  63 */       throw new IllegalArgumentException("Shapeless recipes cannot have more than 9 ingredients");
+/*     */     }
+/*  65 */     while (count-- > 0) {
+/*  66 */       this.ingredients.add(ingredient);
+/*     */     }
+/*  68 */     return this;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe addIngredient(int count, Material ingredient) {
+/*  78 */     return addIngredient(count, ingredient, 0);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe addIngredient(int count, Material ingredient, int rawdata) {
+/*  89 */     MaterialData data = ingredient.getNewData((byte)rawdata);
+/*     */     
+/*  91 */     if (data == null) {
+/*  92 */       data = new MaterialData(ingredient, (byte)rawdata);
+/*     */     }
+/*  94 */     return addIngredient(count, data);
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ShapelessRecipe removeIngredient(MaterialData ingredient) {
+/* 104 */     this.ingredients.remove(ingredient);
+/* 105 */     return this;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ItemStack getResult() {
+/* 113 */     return this.output;
+/*     */   }
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */ 
+/*     */   
+/*     */   public ArrayList<MaterialData> getIngredientList() {
+/* 121 */     return this.ingredients;
+/*     */   }
+/*     */ }
 
-import java.util.ArrayList;
 
-import org.bukkit.Material;
-import org.bukkit.material.MaterialData;
-
-/**
- * Represents a shapeless recipe, where the arrangement of the ingredients on the crafting grid
- * does not matter.
- */
-public class ShapelessRecipe implements Recipe {
-    private ItemStack output;
-    private ArrayList<MaterialData> ingredients = new ArrayList<MaterialData>();
-
-    /**
-     * Create a shapeless recipe to craft the specified ItemStack. The constructor merely determines the
-     * result and type; to set the actual recipe, you'll need to call the appropriate methods.
-     * @param result The item you want the recipe to create.
-     * @see ShapelessRecipe#addIngredient(Material)
-     * @see ShapelessRecipe#addIngredient(MaterialData)
-     */
-    public ShapelessRecipe(ItemStack result) {
-        this.output = result;
-    }
-
-    /**
-     * Adds the specified ingredient.
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(MaterialData ingredient) {
-        return addIngredient(1, ingredient);
-    }
-
-    /**
-     * Adds the specified ingredient.
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(Material ingredient) {
-        return addIngredient(1, ingredient, 0);
-    }
-
-    /**
-     * Adds the specified ingredient.
-     * @param ingredient The ingredient to add.
-     * @param rawdata The data value.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(Material ingredient, int rawdata) {
-        return addIngredient(1, ingredient, rawdata);
-    }
-
-    /**
-     * Adds multiples of the specified ingredient.
-     * @param count How many to add (can't be more than 9!)
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(int count, MaterialData ingredient) {
-        if (ingredients.size() + count > 9) {
-            throw new IllegalArgumentException("Shapeless recipes cannot have more than 9 ingredients");
-        }
-        while (count-- > 0) {
-            ingredients.add(ingredient);
-        }
-        return this;
-    }
-
-    /**
-     * Adds multiples of the specified ingredient.
-     * @param count How many to add (can't be more than 9!)
-     * @param ingredient The ingredient to add.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(int count, Material ingredient) {
-        return addIngredient(count, ingredient, 0);
-    }
-
-    /**
-     * Adds multiples of the specified ingredient.
-     * @param count How many to add (can't be more than 9!)
-     * @param ingredient The ingredient to add.
-     * @param rawdata The data value.
-     * @return The changed recipe, so you can chain calls.
-     */
-    public ShapelessRecipe addIngredient(int count, Material ingredient, int rawdata) {
-        MaterialData data = ingredient.getNewData((byte) rawdata);
-
-        if (data == null) {
-            data = new MaterialData(ingredient, (byte) rawdata);
-        }
-        return addIngredient(count, data);
-    }
-
-    /**
-     * Removes an ingredient from the list. If the ingredient occurs multiple times,
-     * only one instance of it is removed.
-     * @param ingredient The ingredient to remove
-     * @return The changed recipe.
-     */
-    public ShapelessRecipe removeIngredient(MaterialData ingredient) {
-        this.ingredients.remove(ingredient);
-        return this;
-    }
-
-    /**
-     * Get the result of this recipe.
-     * @return The result stack.
-     */
-    public ItemStack getResult() {
-        return output;
-    }
-
-    /**
-     * Get the list of ingredients used for this recipe.
-     * @return The input list
-     */
-    public ArrayList<MaterialData> getIngredientList() {
-        return ingredients;
-    }
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/ShapelessRecipe.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/inventory/Slot.java b/src/main/java/org/bukkit/inventory/Slot.java
index 0e546ca6..5fe7a122 100644
--- a/src/main/java/org/bukkit/inventory/Slot.java
+++ b/src/main/java/org/bukkit/inventory/Slot.java
@@ -1,28 +1,15 @@
 package org.bukkit.inventory;
 
-/**
- * Represents a slot in an inventory
- */
 public interface Slot {
+  Inventory getInventory();
+  
+  int getIndex();
+  
+  ItemStack getItem();
+}
 
-    /**
-     * Gets the inventory this slot belongs to
-     *
-     * @return The inventory
-     */
-    public Inventory getInventory();
-
-    /**
-     * Get the index this slot belongs to
-     *
-     * @return Index of the slot
-     */
-    public int getIndex();
 
-    /**
-     * Get the item from the slot.
-     *
-     * @return ItemStack in the slot.
-     */
-    public ItemStack getItem();
-}
+/* Location:              /home/kobo/Downloads/Canyon-Server/Canyon-API/target/canyon-api.jar!/org/bukkit/inventory/Slot.class
+ * Java compiler version: 8 (52.0)
+ * JD-Core Version:       1.1.3
+ */
\ No newline at end of file
-- 
2.30.0.windows.2

